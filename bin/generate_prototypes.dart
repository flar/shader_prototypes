// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'dart:developer' as dev;
import 'dart:io';
import 'dart:math';

import 'package:args/args.dart';
import 'package:yaml/yaml.dart';

late ArgResults argResults;

String getArtifactsPath() {
  String path = Platform.environment['PATH'] ?? 'PATH=';
  List<String> pathDirs = path.replaceAll('PATH=', '').split(':');
  for (String dir in pathDirs) {
    if (dir.endsWith('bin/cache/dart-sdk/bin')) {
      return dir.replaceAll(r'dart-sdk/bin', 'artifacts/engine/darwin-x64');
    }
  }
  throw 'impellerc not found';
}

dynamic getYaml(YamlMap doc, String spec) {
  List<String> specList = spec.split(':');
  for (int i = 0; i < specList.length - 1; i++) {
    dynamic part = doc[specList[i]];
    if (part is YamlMap) {
      doc = part;
    } else {
      return null;
    }
  }
  return doc[specList.last];
}

String? getYamlString(YamlMap doc, String spec) {
  return getYaml(doc, spec);
}

bool? getYamlBool(YamlMap doc, String spec) {
  return getYaml(doc, spec);
}

String getOutputDir(YamlMap doc) {
  String outputDirArg = argResults.option('output-dir')
      ?? getYamlString(doc, 'shader_prototypes:output')
      ?? 'lib/gen/shader-prototypes';
  if (!outputDirArg.endsWith('/')) {
    outputDirArg += '/';
  }
  return outputDirArg;
}

String artifactsPath = getArtifactsPath();
late String outputDir;
late bool updateGitIgnore;

void main(List<String> args) async {
  ArgParser parser = ArgParser();
  parser.addOption(
    'output-dir',
    help: 'Directory to write the shader class source files.'
  );
  parser.addFlag(
    'force',
    abbr: 'f',
    defaultsTo: false,
    help: 'Rewrite shader prototype files without checking previous contents',
  );
  parser.addFlag('help', abbr: 'h');
  argResults = parser.parse(args);
  if (argResults.flag('help')) {
    sinkAllLines(stdout, <String>[
      'A utility to generate Dart language class definitions from'
          ' fragment shader source files.',
      '',
      'Usage: dart run shader_prototypes:generate_prototypes [arguments]',
      '',
      'Global options:',
      parser.usage,
    ]);
    return;
  }

  final File pubspecFile = File('pubspec.yaml');
  final String yamlString = pubspecFile.readAsStringSync();
  final YamlMap doc = loadYaml(yamlString);

  outputDir = getOutputDir(doc);
  updateGitIgnore = getYamlBool(doc, 'shader_prototypes:update-gitignore') ?? false;

  YamlList shaders = doc['flutter']['shaders'];
  for (var shader in shaders) {
    generatePrototype(shader);
  }
}

enum UniformType {
  float,
  vec2,
  vec3,
  vec4,
  mat4,
  sampler,
}

class Uniform {
  Uniform({required this.type, required this.name, required this.base});

  final UniformType type;
  final String name;
  final int base;

  @override
  String toString() => 'Uniform($type, $name)';
}

void generatePrototype(String shaderPath) {
  File shaderFile = File(shaderPath);
  if (!shaderFile.existsSync()) {
    dev.log("Shader file '$shaderPath' does not exist");
    return;
  }

  List<Uniform> uniforms = extractUniformsImpellerc(shaderFile);
  if (uniforms.isEmpty) {
    dev.log('No uniforms found in $shaderPath');
    return;
  }

  List<String> headerLines = <String>[
    '// GENERATED CODE - DO NOT MODIFY BY HAND',
    '// THIS FILE IS GENERATED BY generate_prototypes.dart FROM $shaderPath.',
    '',
  ];
  List<String> protoFileLines = generatePrototypeFile(shaderPath, uniforms, headerLines);

  String protoPath = shaderPath
      .replaceFirst(RegExp(r'.frag$'), '.dart')
      .replaceFirst(RegExp('^shaders/'), '');
  File protoFile = File('$outputDir/$protoPath');

  if (!argResults['force'] && protoFile.existsSync()) {
    // Check if we can write to it...
    int common = linesInCommon(protoFile, protoFileLines);
    if (common == protoFileLines.length) {
      dev.log('Prototype $protoPath does not need updating');
      return;
    }
    if (common < headerLines.length) {
      throw 'incompatible prototype file exists in $protoPath';
    }
  }

  protoFile.createSync(recursive: true);
  var sink = protoFile.openWrite();
  sinkAllLines(sink, protoFileLines);
  addToGitIgnore(protoPath);
}

void addToGitIgnore(String path) {
  if (!updateGitIgnore) {
    return;
  }
  File ignoreFile = File('$outputDir/.gitignore');
  if (ignoreFile.existsSync()) {
    List<String> existingIgnores = ignoreFile.readAsLinesSync();
    for (var ignore in existingIgnores) {
      if (ignore == path) {
        return;
      }
    }
    String contents = ignoreFile.readAsStringSync();
    if (contents.isNotEmpty && !contents.endsWith('\n')) {
      path = '\n$path';
    }
  }
  ignoreFile.writeAsStringSync('$path\n', mode: FileMode.append);
}

List<Uniform> extractUniformsImpellerc(File shaderFile) {
  /*
   * Not working yet...
  Directory temp = Directory(Directory.systemTemp.path).createTempSync('shader_proto');
  ProcessResult result = Process.runSync('$artifactsPath/impellerc', [
    '--include=$artifactsPath/shader_lib',
    '--input-type=frag',
    '--iplr',
    '--runtime-stage-metal',
    '--input=${shaderFile.path}',
    '--spirv=${temp.path}/shader.spirv',
    '--reflection-json=${temp.path}/shader.json',
    '--sl=${temp.path}/shader.sl',
  ]);
  for (var line in LineSplitter.split(result.stdout)) {
    print('[STDOUT] $line');
  }
  for (var line in LineSplitter.split(result.stderr)) {
    print('[STDERR] $line');
  }
  if (result.exitCode != 0) {
    print('impellerc failed to compile shader ${shaderFile.path} (exit code ${result.exitCode})');
  } else {
    for (var line in File('${temp.path}/shader.json').readAsLinesSync()) {
      print('[JSON]: $line');
    }
    // for (var line in File('${temp.path}/shader.sl').readAsLinesSync()) {
    //   print('[SL]: $line');
    // }
    var json = jsonDecode(File('${temp.path}/shader.json').readAsStringSync());
    print(json['sksl']);
    if (json['sksl'] != null) {
      print(json['sksl']['uniforms']);
    }
  }
  */
  return extractUniformsText(shaderFile);
}

List<Uniform> extractUniformsText(File shaderFile) {
  List<Uniform> uniforms = [];
  List<String> lines = shaderFile.readAsLinesSync();
  int lineNumber = 0;
  int floatIndex = 0;
  int samplerIndex = 0;
  for (var line in lines) {
    lineNumber++;
    line = line.replaceFirst(RegExp(r'//.*$'), '');
    line = line.trim();
    List<String> words = line.split(RegExp(r' +'));
    if (!words.contains('uniform')) {
      continue;
    }
    if (!words.last.endsWith(';')) {
      continue;
    }
    String name = words.last.substring(0, words.last.length - 1);
    if (name.isEmpty) {
      continue;
    }
    int uniformCount = uniforms.length;
    for (String word in words) {
      switch (word) {
        case 'float':
          uniforms.add(
              Uniform(type: UniformType.float, name: name, base: floatIndex));
          floatIndex += 1;
          break;
        case 'vec2':
          uniforms.add(
              Uniform(type: UniformType.vec2, name: name, base: floatIndex));
          floatIndex += 2;
          break;
        case 'vec3':
          uniforms.add(
              Uniform(type: UniformType.vec3, name: name, base: floatIndex));
          floatIndex += 3;
          break;
        case 'vec4':
          uniforms.add(
              Uniform(type: UniformType.vec4, name: name, base: floatIndex));
          floatIndex += 4;
          break;
        case 'mat4':
          uniforms.add(
              Uniform(type: UniformType.mat4, name: name, base: floatIndex));
          floatIndex += 16;
          break;
        case 'sampler2D':
          uniforms.add(Uniform(
              type: UniformType.sampler, name: name, base: samplerIndex));
          samplerIndex += 1;
          break;
        default:
          continue;
      }
      break;
    }
    if (uniformCount == uniforms.length) {
      dev.log('Unrecognized uniform declaration at line $lineNumber: $line');
    }
  }
  return uniforms;
}

List<String> generatePrototypeFile(String shaderPath, List<Uniform> uniforms, List<String> headerLines) {
  String shaderClassName = shaderPath
      .replaceAll(RegExp(r'.*/'), '')
      .replaceAll('.frag', '')
      .replaceAllMapped(RegExp(r'_([a-zA-Z])'), (Match m) => m[1]!.toUpperCase())
      .replaceAllMapped(RegExp(r'^([a-zA-Z])'), (Match m) => m[1]!.toUpperCase());
  List<String> accessLines = <String>[];
  for (var uniform in uniforms) {
    switch (uniform.type) {
      case UniformType.vec2:
        accessLines.add('  late final Vec2 ${uniform.name} = UniformVec2(shader, ${uniform.base});');
        accessLines.add('');
        break;
      case UniformType.vec3:
        accessLines.add('  late final Vec3 ${uniform.name} = UniformVec3(shader, ${uniform.base});');
        accessLines.add('');
        break;
      case UniformType.vec4:
        accessLines.add('  late final Vec4 ${uniform.name} = UniformVec4(shader, ${uniform.base});');
        accessLines.add('');
        break;
      case UniformType.mat4:
        accessLines.add('  late final Mat4 ${uniform.name} = UniformMat4(shader, ${uniform.base});');
        accessLines.add('');
        break;
      case UniformType.float:
        accessLines.add('  double _${uniform.name} = 0.0;');
        accessLines.add('  set ${uniform.name}(double value) {');
        accessLines.add('    _${uniform.name} = value;');
        accessLines.add('    shader.setFloat(${uniform.base}, value);');
        accessLines.add('  }');
        accessLines.add('  double get ${uniform.name} => _${uniform.name};');
        accessLines.add('');
        break;
      case UniformType.sampler:
        accessLines.add('  Image? _${uniform.name};');
        accessLines.add('  set ${uniform.name}(Image image) {');
        accessLines.add('    _${uniform.name} = image;');
        accessLines.add('    shader.setImageSampler(${uniform.base}, image);');
        accessLines.add('  }');
        accessLines.add('  Image? get ${uniform.name} => _${uniform.name};');
        accessLines.add('');
        break;
    }
  }

  return <String>[
    ...headerLines,
    "import 'dart:ui';",
    '',
    "import 'package:shader_prototypes/shader_prototypes.dart';",
    '',
    'class $shaderClassName {',
    '  $shaderClassName() : shader = _program!.fragmentShader();',
    '',
    '  final FragmentShader shader;',
    '',
    ...accessLines,
    '  static FragmentProgram? _program;',
    '  static Future<void> init() async {',
    "    _program = await FragmentProgram.fromAsset('$shaderPath');",
    '  }',
    '}',
  ];
}

int linesInCommon(File protoFile, List<String> newPrototypeLines) {
  List<String> existingLines = protoFile.readAsLinesSync();
  int commonLineCount = min(existingLines.length, newPrototypeLines.length);
  for (int i = 0; i < commonLineCount; i++) {
    if (existingLines[i] != newPrototypeLines[i]) {
      dev.log("header line ${i + 1} in ${protoFile.path} doesn't match expected: "
          "${existingLines[i]} != ${newPrototypeLines[i]}");
      return i;
    }
  }
  return commonLineCount;
}

void sinkAllLines(IOSink sink, List<String> lines) {
  for (String line in lines) {
    sink.writeln(line);
  }
  sink.flush();
}
