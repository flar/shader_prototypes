// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'dart:developer' as dev;
import 'dart:io';
import 'dart:math';

import 'package:args/args.dart';
import 'package:yaml/yaml.dart';

late ArgResults argResults;

void main(List<String> args) async {
  ArgParser parser = ArgParser();
  parser.addOption(
    'output-dir',
    defaultsTo: 'lib/src/gen/shader_prototypes',
    help: 'Directory to write the shader class source files.'
  );
  parser.addFlag('help', abbr: 'h');
  argResults = parser.parse(args);
  if (argResults.flag('help')) {
    print('A utility to generate Dart language class definitions from fragment shader source files.');
    print('');
    print('Usage: dart run shader_prototypes:generate_prototypes [arguments]');
    print('');
    print('Global options:');
    print(parser.usage);
    return;
  }

  final File pubspecFile = File('pubspec.yaml');
  final String yamlString = pubspecFile.readAsStringSync();
  final YamlMap doc = loadYaml(yamlString);

  YamlList shaders = doc['flutter']['shaders'];
  for (var shader in shaders) {
    generatePrototype(shader);
  }
}

enum UniformType {
  float,
  vec2,
  vec3,
  vec4,
  mat4,
  sampler,
}

class Uniform {
  Uniform({required this.type, required this.name, required this.base});

  final UniformType type;
  final String name;
  final int base;

  @override
  String toString() => 'Uniform($type, $name)';
}

void generatePrototype(String shaderPath) {
  File shaderFile = File(shaderPath);
  if (!shaderFile.existsSync()) {
    dev.log("Shader file '$shaderPath' does not exist");
    return;
  }

  List<Uniform> uniforms = extractUniforms(shaderFile);
  if (uniforms.isEmpty) {
    dev.log('No uniforms found in $shaderPath');
    return;
  }

  List<String> headerLines = <String>[
    '// THIS FILE IS GENERATED BY generate_prototypes.dart FROM $shaderPath.',
    '// DO NOT EDIT OR CHECK THIS INTO SOURCE CONTROL',
    '',
  ];
  List<String> protoFileLines = generatePrototypeFile(shaderPath, uniforms, headerLines);

  String outputDir = argResults.option('output-dir')!;
  if (!outputDir.endsWith('/')) {
    outputDir += '/';
  }
  String protoPath = '$outputDir/${shaderPath
      .replaceFirst(RegExp(r'.frag$'), '.dart')}';
  File protoFile = File(protoPath);

  if (protoFile.existsSync()) {
    // Check if we can write to it...
    int common = linesInCommon(protoFile, protoFileLines);
    if (common == protoFileLines.length) {
      dev.log('Prototype $protoPath does not need updating');
      return;
    }
    if (common < headerLines.length) {
      throw 'incompatible prototype file exists in $protoPath';
    }
  }

  protoFile.createSync(recursive: true);
  var sink = protoFile.openWrite();
  for (String line in protoFileLines) {
    sink.writeln(line);
  }
  sink.flush();
}

List<Uniform> extractUniforms(File shaderFile) {
  List<Uniform> uniforms = [];
  List<String> lines = shaderFile.readAsLinesSync();
  int lineNumber = 0;
  int floatIndex = 0;
  int samplerIndex = 0;
  for (var line in lines) {
    lineNumber++;
    line = line.trim();
    line = line.replaceFirst(RegExp(r'//.*$'), '');
    List<String> words = line.split(RegExp(r' +'));
    if (words.length >= 3 && words[0] == 'uniform' && words[2].endsWith(';')) {
      String name = words[2].substring(0, words[2].length - 1);
      switch (words[1]) {
        case 'vec2':
          uniforms.add(
              Uniform(type: UniformType.vec2, name: name, base: floatIndex));
          floatIndex += 2;
          break;
        case 'vec3':
          uniforms.add(
              Uniform(type: UniformType.vec3, name: name, base: floatIndex));
          floatIndex += 3;
          break;
        case 'vec4':
          uniforms.add(
              Uniform(type: UniformType.vec4, name: name, base: floatIndex));
          floatIndex += 4;
          break;
        case 'mat4':
          uniforms.add(
              Uniform(type: UniformType.mat4, name: name, base: floatIndex));
          floatIndex += 16;
          break;
        case 'float':
          uniforms.add(
              Uniform(type: UniformType.float, name: name, base: floatIndex));
          floatIndex += 1;
          break;
        case 'sampler2D':
          uniforms.add(Uniform(
              type: UniformType.sampler, name: name, base: samplerIndex));
          samplerIndex += 1;
          break;
        default:
          dev.log('Unrecognized uniform declaration at line $lineNumber: $line');
          break;
      }
    }
  }
  return uniforms;
}

List<String> generatePrototypeFile(String shaderPath, List<Uniform> uniforms, List<String> headerLines) {
  String shaderClassName = shaderPath
      .replaceAll(RegExp(r'.*/'), '')
      .replaceAll('.frag', '')
      .replaceAllMapped(RegExp(r'_([a-zA-Z])'), (Match m) => m[1]!.toUpperCase())
      .replaceAllMapped(RegExp(r'^([a-zA-Z])'), (Match m) => m[1]!.toUpperCase());
  List<String> initLines = <String>[];
  List<String> accessLines = <String>[];
  for (var uniform in uniforms) {
    switch (uniform.type) {
      case UniformType.vec2:
        initLines.add('${uniform.name} = UniformVec2(shader, ${uniform.base});');
        accessLines.add('late final UniformVec2 ${uniform.name};');
        break;
      case UniformType.vec3:
        initLines.add('${uniform.name} = UniformVec3(shader, ${uniform.base});');
        accessLines.add('late final UniformVec3 ${uniform.name};');
        break;
      case UniformType.vec4:
        initLines.add('${uniform.name} = UniformVec4(shader, ${uniform.base});');
        accessLines.add('late final UniformVec4 ${uniform.name};');
        break;
      case UniformType.mat4:
        initLines.add('_${uniform.name} = UniformMat4(shader, ${uniform.base});');
        accessLines.add('late final UniformMat4 ${uniform.name};');
        break;
      case UniformType.float:
        accessLines.add('set ${uniform.name}(double value) => shader.setFloat(${uniform.base}, value);');
        break;
      case UniformType.sampler:
        accessLines.add('set ${uniform.name}(Image image) => shader.setImageSampler(${uniform.base}, image);');
        break;
    }
  }

  return <String>[
    ...headerLines,
    "import 'dart:ui';",
    '',
    "import 'package:shader_prototypes/shader_prototypes.dart';",
    '',
    'class $shaderClassName {',
    '  $shaderClassName() {',
    '    shader = _program!.fragmentShader();',
    for (String line in initLines)
      '    $line',
    '  }',
    '',
    '  late final FragmentShader shader;',
    '',
    for (String line in accessLines)
      '  $line',
    '',
    '  static FragmentProgram? _program;',
    '  static Future<void> init() async {',
    "    _program = await FragmentProgram.fromAsset('$shaderPath');",
    '  }',
    '}',
  ];
}

int linesInCommon(File protoFile, List<String> newPrototypeLines) {
  List<String> existingLines = protoFile.readAsLinesSync();
  int commonLineCount = min(existingLines.length, newPrototypeLines.length);
  for (int i = 0; i < commonLineCount; i++) {
    if (existingLines[i] != newPrototypeLines[i]) {
      dev.log("header line ${i + 1} in ${protoFile.path} doesn't match expected: "
          "${existingLines[i]} != ${newPrototypeLines[i]}");
      return i;
    }
  }
  return commonLineCount;
}
