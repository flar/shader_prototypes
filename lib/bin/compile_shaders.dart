import 'dart:developer';
import 'dart:io';

import 'package:yaml/yaml.dart';

void main() {
  final File pubspecFile = File('pubspec.yaml');
  final String yamlString = pubspecFile.readAsStringSync();
  final YamlMap doc = loadYaml(yamlString);

  YamlList shaders = doc['flutter']['shaders'];
  for (var shader in shaders) {
    parse(shader);
  }
}

enum UniformType {
  float,
  vec2,
  vec3,
  vec4,
  mat4,
  sampler,
}

class Uniform {
  Uniform({required this.type, required this.name, required this.base});

  final UniformType type;
  final String name;
  final int base;

  @override
  String toString() => 'Uniform($type, $name)';
}

void parse(String shaderPath) {
  File shaderFile = File(shaderPath);
  if (!shaderFile.existsSync()) {
    log("Shader file '$shaderPath' does not exist");
    return;
  }

  List<Uniform> uniforms = [];
  List<String> lines = shaderFile.readAsLinesSync();
  int lineNumber = 0;
  int floatIndex = 0;
  int samplerIndex = 0;
  for (var line in lines) {
    lineNumber++;
    line = line.trim();
    line = line.replaceFirst(RegExp(r'//.*$'), '');
    List<String> words = line.split(RegExp(r' +'));
    if (words.length >= 3 && words[0] == 'uniform' && words[2].endsWith(';')) {
      String name = words[2].substring(0, words[2].length - 1);
      switch (words[1]) {
        case 'vec2':
          uniforms.add(Uniform(type: UniformType.vec2, name: name, base: floatIndex));
          floatIndex += 2;
          break;
        case 'vec3':
          uniforms.add(Uniform(type: UniformType.vec3, name: name, base: floatIndex));
          floatIndex += 3;
          break;
        case 'vec4':
          uniforms.add(Uniform(type: UniformType.vec4, name: name, base: floatIndex));
          floatIndex += 4;
          break;
        case 'mat4':
          uniforms.add(Uniform(type: UniformType.mat4, name: name, base: floatIndex));
          floatIndex += 16;
          break;
        case 'float':
          uniforms.add(Uniform(type: UniformType.float, name: name, base: floatIndex));
          floatIndex += 1;
          break;
        case 'sampler2D':
          uniforms.add(Uniform(type: UniformType.sampler, name: name, base: samplerIndex));
          samplerIndex += 1;
          break;
        default:
          log('Unrecognized uniform declaration at line $lineNumber: $line');
          break;
      }
    }
  }

  String protoPath = shaderPath
      .replaceFirst('shaders', 'lib/src/shaders')
      .replaceFirst(RegExp(r'.frag$'), '.dart');
  File protoFile = File(protoPath);
  List<String> headerLines = <String>[
    '// THIS FILE IS GENERATED BY compile_shaders.dart FROM $shaderPath.',
    '// DO NOT EDIT OR CHECK THIS INTO SOURCE CONTROL'
    '',
  ];
  String shaderClassName = shaderPath
      .replaceAll(RegExp(r'.*/'), '')
      .replaceAll('.frag', '')
      .replaceAllMapped(RegExp(r'_([a-zA-Z])'), (Match m) => m[1]!.toUpperCase())
      .replaceAllMapped(RegExp(r'^([a-zA-Z])'), (Match m) => m[1]!.toUpperCase());
  if (!canWrite(protoFile, headerLines)) {
    return;
  }
  List<String> initLines = <String>[];
  List<String> accessLines = <String>[];
  List<String> variableLines = <String>[];
  for (var uniform in uniforms) {
    switch (uniform.type) {
      case UniformType.vec2:
        initLines.add('    _${uniform.name} = UniformVec2(shader, ${uniform.base});');
        accessLines.add('  UniformVec2 get ${uniform.name} => _${uniform.name};');
        variableLines.add('  late final UniformVec2 _${uniform.name};');
        break;
      case UniformType.vec3:
        initLines.add('    _${uniform.name} = UniformVec3(shader, ${uniform.base});');
        accessLines.add('  UniformVec3 get ${uniform.name} => _${uniform.name};');
        variableLines.add('  late final UniformVec3 _${uniform.name};');
        break;
      case UniformType.vec4:
        initLines.add('    _${uniform.name} = UniformVec4(shader, ${uniform.base});');
        accessLines.add('  UniformVec4 get ${uniform.name} => _${uniform.name};');
        variableLines.add('  late final UniformVec4 _${uniform.name};');
        break;
      case UniformType.mat4:
        initLines.add('    _${uniform.name} = UniformMat4(shader, ${uniform.base});');
        accessLines.add('  UniformMat4 get ${uniform.name} => _${uniform.name};');
        variableLines.add('  late final UniformMat4 _${uniform.name};');
        break;
      case UniformType.float:
        accessLines.add('  set ${uniform.name}(double value) => shader.setFloat(${uniform.base}, value);');
        break;
      case UniformType.sampler:
        accessLines.add('  set ${uniform.name}(Image image) => shader.setImageSampler(${uniform.base}, image);');
        break;
    }
  }
  protoFile.createSync(recursive: true);
  var sink = protoFile.openWrite();
  writeLines(sink, headerLines);
  sink.writeln("import 'dart:ui';");
  sink.writeln();
  sink.writeln("import 'package:shader_prototypes/shader_prototypes.dart';");
  sink.writeln();
  sink.writeln('class $shaderClassName {');
  sink.writeln('  $shaderClassName() {');
  sink.writeln('    shader = _program!.fragmentShader();');
  writeLines(sink, initLines);
  sink.writeln('  }');
  sink.writeln();
  sink.writeln('  late final FragmentShader shader;');
  writeLines(sink, accessLines);
  sink.writeln();
  writeLines(sink, variableLines);
  sink.writeln();
  sink.writeln('  static FragmentProgram? _program;');
  sink.writeln('  static Future<void> init() async {');
  sink.writeln("    _program = await FragmentProgram.fromAsset('$shaderPath');");
  sink.writeln('  }');
  sink.writeln('}');
  sink.flush();
}

bool canWrite(File protoFile, List<String> headerLines) {
  if (!protoFile.existsSync()) {
    return true;
  }
  List<String> lines = protoFile.readAsLinesSync();
  if (lines.length < headerLines.length) {
    log('too few lines in ${protoFile.path} ${lines.length} < ${headerLines.length}');
    return false;
  }
  for (int i = 0; i < headerLines.length; i++) {
    if (lines[i] != headerLines[i]) {
      log("header line ${i + 1} in ${protoFile.path} doesn't match expected: ${lines[i]} != ${headerLines[i]}");
      return false;
    }
  }
  return true;
}

void writeLines(IOSink sink, List<String> lines) {
  for (var line in lines) {
    sink.writeln(line);
  }
}