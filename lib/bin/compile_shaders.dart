import 'dart:io';

import 'package:yaml/yaml.dart';

void main() {
  final File pubspecFile = File('pubspec.yaml');
  final String yamlString = pubspecFile.readAsStringSync();
  final YamlMap doc = loadYaml(yamlString);

  YamlList shaders = doc['flutter']['shaders'];
  for (var shader in shaders) {
    parse(shader);
  }
}

enum UniformType {
  vec2,
  vec4,
  mat4,
  float,
}

class Uniform {
  Uniform({required this.type, required this.name, required this.base});

  final UniformType type;
  final String name;
  final int base;

  @override
  String toString() => 'Uniform($type, $name)';
}

parse(String shaderPath) {
  File shaderFile = File(shaderPath);
  if (!shaderFile.existsSync()) {
    print("Shader file '$shaderPath' does not exist");
    return;
  }

  List<Uniform> uniforms = [];
  List<String> lines = shaderFile.readAsLinesSync();
  int lineNumber = 0;
  int uniformBase = 0;
  for (var line in lines) {
    lineNumber++;
    line = line.trim();
    line = line.replaceFirst(RegExp(r'//.*$'), '');
    List<String> words = line.split(RegExp(r'[ ]+'));
    if (words.length >= 3 && words[0] == 'uniform' && words[2].endsWith(';')) {
      String name = words[2].substring(0, words[2].length - 1);
      switch (words[1]) {
        case 'vec2':
          uniforms.add(Uniform(type: UniformType.vec2, name: name, base: uniformBase));
          uniformBase += 2;
          break;
        case 'vec4':
          uniforms.add(Uniform(type: UniformType.vec4, name: name, base: uniformBase));
          uniformBase += 4;
          break;
        case 'mat4':
          uniforms.add(Uniform(type: UniformType.mat4, name: name, base: uniformBase));
          uniformBase += 16;
          break;
        case 'float':
          uniforms.add(Uniform(type: UniformType.float, name: name, base: uniformBase));
          uniformBase += 1;
          break;
        default:
          print('Unrecognized uniform declaration: $line');
      }
    }
  }

  String protoPath = shaderPath
      .replaceFirst('shaders', 'lib/src/shaders')
      .replaceFirst(RegExp(r'.frag$'), '.dart');
  File protoFile = File(protoPath);
  List<String> headerLines = <String>[
    '// Do not edit this file',
    '// It was auto-generated by compile_shaders.dart from $shaderPath',
    '',
  ];
  String shaderClassName = 'Shader';
  if (!canWrite(protoFile, headerLines)) {
    return;
  }
  List<String> initLines = <String>[];
  List<String> getLines = <String>[];
  List<String> variableLines = <String>[];
  for (var uniform in uniforms) {
    switch (uniform.type) {
      case UniformType.vec2:
        initLines.add('    _${uniform.name} = UniformVec2(shader, ${uniform.base});');
        getLines.add('  UniformVec2 get ${uniform.name} => _${uniform.name};');
        variableLines.add('  late final UniformVec2 _${uniform.name};');
        break;
      case UniformType.vec4:
        initLines.add('    _${uniform.name} = UniformVec4(shader, ${uniform.base});');
        getLines.add('  UniformVec4 get ${uniform.name} => _${uniform.name};');
        variableLines.add('  late final UniformVec4 _${uniform.name};');
        break;
      case UniformType.mat4:
        initLines.add('    _${uniform.name} = UniformMat4(shader, ${uniform.base});');
        getLines.add('  UniformMat4 get ${uniform.name} => _${uniform.name};');
        variableLines.add('  late final UniformMat4 _${uniform.name};');
        break;
      case UniformType.float:
        getLines.add('  set ${uniform.name}(double value) => shader.setFloat(${uniform.base}, value);');
        break;
    }
  }
  protoFile.createSync(recursive: true);
  var sink = protoFile.openWrite();
  dumpLines(sink, headerLines);
  sink.writeln("import 'dart:ui';");
  sink.writeln();
  sink.writeln("import 'package:shader_prototypes/shader_prototypes.dart';");
  sink.writeln();
  sink.writeln('class $shaderClassName {');
  sink.writeln('  static FragmentProgram? _program;');
  sink.writeln();
  sink.writeln('  $shaderClassName() {');
  sink.writeln('    shader = _program!.fragmentShader();');
  dumpLines(sink, initLines);
  sink.writeln('  }');
  sink.writeln();
  dumpLines(sink, getLines);
  sink.writeln();
  dumpLines(sink, variableLines);
  sink.writeln();
  sink.writeln('  late final FragmentShader shader;');
  sink.writeln();
  sink.writeln('  static Future<void> init() async {');
  sink.writeln("    _program = await FragmentProgram.fromAsset('$shaderPath');");
  sink.writeln('  }');
  sink.writeln('}');
  sink.flush();
}

bool canWrite(File protoFile, List<String> headerLines) {
  if (!protoFile.existsSync()) {
    return true;
  }
  List<String> lines = protoFile.readAsLinesSync();
  if (lines.length < headerLines.length) {
    print('too few lines ${lines.length} < ${headerLines.length}');
    return false;
  }
  for (int i = 0; i < headerLines.length; i++) {
    if (lines[i] != headerLines[i]) {
      print("header line ${i + 1} doesn't match: ${lines[i]} != ${headerLines[i]}");
      return false;
    }
  }
  return true;
}

void dumpLines(IOSink sink, List<String> lines) {
  for (var line in lines) {
    sink.writeln(line);
  }
}